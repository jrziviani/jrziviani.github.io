---
title: "Functions in Assembly - Part I"
tags: ['C', 'assembly']
date: 2017-10-25T09:04:06-08:00
draft: false
author: "Jose R. Ziviani"
showToc: true
TocOpen: false
comments: false
disableHLJS: true
searchHidden: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
summary: "What is a function from assembly's point of view and how to write it. Part I."
---
**UPDATE**: [Part II](/2017/functions-in-assembly-ii) is ready.

In my current job I often need to write instructions in assembly. It's usually an one-line instruction so I simply embed it in C using inline asm. But when I need to write more than an one-line code I would prefer to write them directly in assembly.

### Is that difficult?

Function is a sequence of instructions grouped in a logical sense to perform a particular task, they are abstractions implemented by the programming language. The code generated by compilers make use of labels and jumps, stack and registers. So, you basically need to do the job that your compiler does to you. It's not difficult but requires some extra work, for instance:

{{< highlight console >}}
    cat function.S
{{< / highlight >}}

{{< highlight asm >}}
    .align 2
    .type my_function,@function;
    .globl my_function;
    my_function:
        blr
{{< / highlight >}}

*   **.align 2** - section is 2-byte aligned.
*   **.type my\_function,@function** - useful for debugging, not required.
*   **.globl my\_funcion** - "my\_function" is available outside from this unit.
*   **my\_function:** - label.
*   **blr** - PowerPC instruction that branches unconditionally to the address stored in Link Register.

{{< highlight console >}}
    $ cat function.c
{{< / highlight >}}

{{< highlight c >}}
    #include <stdio.h>
    
    /*
     * I'm telling to C compiler that my_function expects and returns an integer.
     * I'm also making a promise: the implementation will be available later.
     */
    extern int my_function(int param);
    
    int main(void)
    {
        int i = my_function(5);
        printf("%d\n", i);
        return 0;
    }
{{< / highlight >}}

{{< highlight console >}}
    $ gcc -g3 function.S function.c -o function
    $ ./function
    5
{{< / highlight >}}

Isn't it cool? I just wrote a "function" in assembly that does nothing more than returning the same value used as parameter. Magic? No, and we will see why.

### Application Binary Interface - ABI

To write a compliant C function we need to respect some rules _(the same rules that the C compiler respects when it generates the binary code)_. These rules are defined by the ABI, or [Application Binary Interface](https://en.wikipedia.org/wiki/Application_binary_interface), that is tied to the target architecture.

About function, it defines rules like: where parameters are a expected to be, how to set up your stack frame, where to store the return values, etc. Those rules help to organize the system in a way that multiple languages can interact with each other (calling libraries, for instance) without problems.

The following interactive animation illustrates an imaginary toy processor and how functions work within its simple specification: 3 registers and some memory. This is the code that would be generated by a C compiler for that imaginary target.

{{< highlight c >}}
    int x = mult(5, 3);
    printf("%d", x);
    int y = mult(x, 2);
    printf("%d", y);
{{< / highlight >}}

> **Note:** click **'n'** to go to the next instruction, this is a simple (but real) [virtual machine](/vm.js).

{{< minivm >}}
