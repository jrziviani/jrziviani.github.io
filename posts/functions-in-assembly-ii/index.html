<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Functions in Assembly - Part II | ziviani.net</title>
<meta name=keywords content="C,assembly">
<meta name=description content="What is a function from assembly&rsquo;s point of view and how to write it. Part II.">
<meta name=author content="Jose R. Ziviani">
<link rel=canonical href=https://jrziviani.github.io/posts/functions-in-assembly-ii/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=icon href=https://jrziviani.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://jrziviani.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://jrziviani.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://jrziviani.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://jrziviani.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<link rel=alternate hreflang=en href=https://jrziviani.github.io/posts/functions-in-assembly-ii/>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Functions in Assembly - Part II">
<meta property="og:description" content="What is a function from assembly&rsquo;s point of view and how to write it. Part II.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jrziviani.github.io/posts/functions-in-assembly-ii/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-11-18T09:04:30-08:00">
<meta property="article:modified_time" content="2017-11-18T09:04:30-08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Functions in Assembly - Part II">
<meta name=twitter:description content="What is a function from assembly&rsquo;s point of view and how to write it. Part II.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jrziviani.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Functions in Assembly - Part II","item":"https://jrziviani.github.io/posts/functions-in-assembly-ii/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Functions in Assembly - Part II","name":"Functions in Assembly - Part II","description":"What is a function from assembly\u0026rsquo;s point of view and how to write it. Part II.","keywords":["C","assembly"],"articleBody":"The Call Stack The real ABI is big, it has pages and more pages explaining the low-level system, object files, dynamic linking, and so on. The fully implementation is beyond the scope of this little project, of course. Here, I will focus in a small part of it which I think is enough to accomplish what I want. Let’s start with the figure below:\n This figure is the image of a call stack. In a nutshell, the call stack exists to assure that functions can live in accordance with other functions, to assure that none of your local variables or your return address will change just because you called printf(), or that you can write your recursive algorithm without worrying whether it will return correctly or not. Concluding, what we really need to do is to build the call stack for our function according to the ABI.\nThus, according to this ABI, I will be able to build the call stack by allocating 160 bytes from the stack, save each of those “things” (we’ll see them soon) in the gray area, and it’s done. Beautiful! But let’s address some questions first.\nPowerPC64 ABI questions How can I get the stack pointer?\nABI states that\n The stack pointer, r1, shall always point to the lowest address doubleword of the most recently allocated stack frame.\n PowerPC64 has 32 general purpose registers and, as per ABI, the register named R1 was chosen to keep the stack address.\nHow do I “allocate” memory from the stack?\nThe stack is already allocated, the operating system did that for you. In PowerPC64 (and RISC) you use store instructions to save data into memory and load instructions to load data from memory. By adding/subtracting from r1, you set the stack pointer to the right slot.\nWhat are those “things” in the gray area?\n Back Chain: is the address of the last stack frame. Each function stores the last stack frame address in its own to make it easy to unwind frames whenever necessary. For instance, imagine how that could be useful if you are writing the exception mechanism of your language. CR Save: In PowerPC, CR (Condition Register) is a 32-bit register that reflects the results of some operations and provides mechanism for testing/branching. Before changing any bit in it a copy must be saved in the stack and restored before returning. Reserved: This space shouldn’t be touched. LR Save: LR (Link Register) has the address to which our function should return to. The caller, before calling your function, is responsible to set this register and you are responsible to keep it as is. If you intend to call another function (or a recursive call), then you need to save the LR here and restore it before returning. TOC Pointer: TOC pointer is stored in register R2 as per ABI. It’s also your responsibility to make sure it will have same value when your function returns. TOC stands for “Table Of Contents” and it’s how PowerPC combines GOT (Global Offset Table, used to hold address for PIC) and small data section. More information can be found in the references below. Parameter Save Area (optional): In PowerPC, parameters are usually passed by registers (remember, there’re 32 general purpose registers). So I don’t know much about this one, I read that C variadic arguments int printf (const char *format, ... ) uses it. Another big advantage of using registers is that all operations in RISC architectures are done within registers so it’s an overhead to [store to]/[load from] memory if we can keep data in registers. Local Variable Space (optional): Each local variable used by the function can be stored here. To know more about these other areas, please refer to: 64-Bit ELF V2 ABI Specification: Power Architecture.  Why are 160 bytes allocated from the stack?:\n32 bytes is the minimum required, then 8 times 8 bytes for the Parameter Save Area (if needed), and 8 times 8 bytes for the Local Variable Space (if needed); 32 + (8 * 8) + (8 * 8) = 160 (it’s also doubleword aligned). This is certainly not optimized but attends my requirement to have some generic for testing purposes.\nParameters As I wrote above, parameters are passed in registers, PowerPC64 ABI assigns 8 registers for it from R3 to R13. Vector and floating point data are passed in their own registers but this project don’t cover them.\nReturn Values As per the ABI\n Functions that return values of the following types shall place the result in register r3 as signed or unsigned integers, as appropriate, and sign extended or zero extended to 64 bits where necessary:\n char enum short int long pointer to any type _Bool   Answer to Part I question The code int i = my_function(5); // i == 5 should makes sense now: main() puts 5 in R3 register as argument to my_function(), which is the same register used to return value. Thus, after my_function() returns, main() reads the return value from R3 which is, in this case, still 5.\nThe Code .align 2 .type my_function,@function;  .globl my_function;  my_function: addis 2, 12, .TOC.-my_function@ha;  addi 2, 2, .TOC.-my_function@l;  .localentry my_function, .-my_function mflr 0 std 0, 16(1) stdu 1, -160(1) add 3, 3, 4 addi 1, 1, 160 ld 0, 16(1) mtlr 0 blr All instructions here exists to build the call stack, except add 3, 3, 4. The code before the computation code is named prologue. In this case, it initializes the TOC pointer in register R2 for the following reason:\n All functions have a global entry point (GEP) available to any caller and pointing to the beginning of the prologue. Some functions may have a secondary entry point to optimize the cost of TOC pointer management. In particular, functions within a common module sharing the same TOC base value in r2 may be entered using a secondary entry point (the local entry point or LEP) that may bypass the code that loads a suitable TOC pointer value into the r2 register. When a dynamic or global linker transfers control from a function to another function in the same module, it may choose (but is not required) to use the local entry point when the r2 register is known to hold a valid TOC base value.\n Basically, the prologue handles the TOC pointer, saves the Link Register and “allocates” 160 bytes by setting the stack pointer. After the computation code, we have the epilogue which restores the prologue before returning. In this case, we reset the stack pointer 160 bytes, load the LR address to R0 and put that value back into the Link Register and return.\nTo know more about PowerPC instruction set, checkout IBM Power ISA™ Version 3.0B.\nThe End Just to make things easier we can create a macro to add both prologue/epilogue for us:\n$ cat util.h  #ifndef _UTIL_H  #define _UTIL_H  #define FUNCTION(name) \\  .align 2; \\  .type name, @function; \\  .globl name; \\  name: \\ addis 2, 12, .TOC.-name@ha; \\  addi 2, 2, .TOC.-name@l; \\  .localentry name,.-name; \\  mflr 0; \\  std 0, 16(1); \\  stdu 1, -160(1);  #define ENDFUNCTION \\  addi 1, 1, 160; \\  ld 0, 16(1); \\  mtlr 0; \\  blr;  #endif $ cat function.S  #include \"util.h\"  .align 2 .printf_fmt: .string \"\\t= %d\\n\" FUNCTION(print_sum) add 4, 4, 3 addis 3, 2, .printf_fmt@toc@ha addi 3, 3, .printf_fmt@toc@l bl printf nop ENDFUNCTION $ cat function.c  #include  extern void print_sum(int a, int b); int main(void) { print_sum(10, 8); printf(\"Works! ;-)\\n\"); return 0; } $ gcc function.S function.c -o function $ ./function = 18 Works! ;-)  References  PowerPC 64-bit ELF V2 ABI IBM Power ISA™ Version 3.0B Application binary interface Call Stack PowerPC Assembly Function calls and the PowerPC 64-bit ABI  ","wordCount":"1286","inLanguage":"en","datePublished":"2017-11-18T09:04:30-08:00","dateModified":"2017-11-18T09:04:30-08:00","author":{"@type":"Person","name":"Jose R. Ziviani"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jrziviani.github.io/posts/functions-in-assembly-ii/"},"publisher":{"@type":"Organization","name":"ziviani.net","logo":{"@type":"ImageObject","url":"https://jrziviani.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://jrziviani.github.io accesskey=h title="ziviani.net (Alt + H)">ziviani.net</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://jrziviani.github.io/pt/ title=Portuguese aria-label=:pt:>Pt</a>
</li>
</ul>
</span>
</div>
<ul id=menu>
<li>
<a href=https://jrziviani.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://jrziviani.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://jrziviani.github.io/tags title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://jrziviani.github.io/about title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://jrziviani.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jrziviani.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Functions in Assembly - Part II
</h1>
<div class=post-meta><span title="2017-11-18 09:04:30 -0800 -0800">November 18, 2017</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Jose R. Ziviani
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#the-call-stack aria-label="The Call Stack">The Call Stack</a></li>
<li>
<a href=#powerpc64-abi-questions aria-label="PowerPC64 ABI questions">PowerPC64 ABI questions</a></li>
<li>
<a href=#parameters aria-label=Parameters>Parameters</a></li>
<li>
<a href=#return-values aria-label="Return Values">Return Values</a></li>
<li>
<a href=#answer-to-part-i2017functions-in-assembly-question aria-label="Answer to Part I question">Answer to <a href=/2017/functions-in-assembly>Part I</a> question</a></li>
<li>
<a href=#the-code aria-label="The Code">The Code</a></li>
<li>
<a href=#the-end aria-label="The End">The End</a></li>
<li>
<a href=#references aria-label=References>References</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h3 id=the-call-stack>The Call Stack<a hidden class=anchor aria-hidden=true href=#the-call-stack>#</a></h3>
<p>The real ABI is big, it has pages and more pages explaining the low-level system, object files, dynamic linking, and so on. The fully implementation is beyond the scope of this little project, of course. Here, I will focus in a small part of it which I think is enough to accomplish what I want. Let&rsquo;s start with the figure below:</p>
<p><a href="https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture"><img loading=lazy src=/func_assembly_stack_frame.png alt="stack frame diagram">
</a> This figure is the image of a <a href=https://en.wikipedia.org/wiki/Call_stack>call stack</a>. In a nutshell, the call stack exists to assure that functions can live in accordance with other functions, to assure that none of your local variables or your return address will change just because you called <code>printf()</code>, or that you can write your recursive algorithm without worrying whether it will return correctly or not. Concluding, what we <strong>really</strong> need to do is to build the call stack for our function <strong>according</strong> to the ABI.</p>
<p>Thus, according to <a href="https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture">this ABI</a>, I will be able to build the call stack by <em>allocating</em> 160 bytes from the stack, save each of those &ldquo;things&rdquo; (we&rsquo;ll see them soon) in the gray area, and it&rsquo;s done. Beautiful! But let&rsquo;s address some questions first.</p>
<h3 id=powerpc64-abi-questions>PowerPC64 ABI questions<a hidden class=anchor aria-hidden=true href=#powerpc64-abi-questions>#</a></h3>
<p><strong>How can I get the stack pointer?</strong></p>
<p>ABI states that</p>
<blockquote>
<p>The stack pointer, r1, shall always point to the lowest address doubleword of the most recently allocated stack frame.</p>
</blockquote>
<p>PowerPC64 has 32 general purpose registers and, as per ABI, the register named <strong>R1</strong> was chosen to keep the stack address.</p>
<p><strong>How do I &ldquo;allocate&rdquo; memory from the stack?</strong></p>
<p>The stack is already allocated, the operating system did that for you. In PowerPC64 (and RISC) you use <strong>store</strong> instructions to save data into memory and <strong>load</strong> instructions to load data from memory. By adding/subtracting from <code>r1</code>, you set the stack pointer to the right slot.</p>
<p><strong>What are those &ldquo;things&rdquo; in the gray area?</strong></p>
<ul>
<li><strong>Back Chain</strong>: is the address of the last stack frame. Each function stores the last stack frame address in its own to make it easy to unwind frames whenever necessary. For instance, imagine how that could be useful if you are writing the exception mechanism of your language.</li>
<li><strong>CR Save</strong>: In PowerPC, CR (Condition Register) is a 32-bit register that reflects the results of some operations and provides mechanism for testing/branching. Before changing any bit in it a copy must be saved in the stack and restored before returning.</li>
<li><strong>Reserved</strong>: This space shouldn&rsquo;t be touched.</li>
<li><strong>LR Save</strong>: LR (Link Register) has the address to which our function should return to. The caller, before calling your function, is responsible to set this register and you are responsible to keep it as is. If you intend to call another function (or a recursive call), then you need to save the LR here and restore it before returning.</li>
<li><strong>TOC Pointer</strong>: TOC pointer is stored in register <strong>R2</strong> as per ABI. It&rsquo;s also your responsibility to make sure it will have same value when your function returns. TOC stands for &ldquo;Table Of Contents&rdquo; and it&rsquo;s how PowerPC combines GOT (Global Offset Table, used to hold address for <a href=https://en.wikipedia.org/wiki/Position-independent_code>PIC</a>) and small data section. More information can be found in the references below.</li>
<li><strong>Parameter Save Area (optional)</strong>: In PowerPC, parameters are usually passed by registers (remember, there&rsquo;re 32 general purpose registers). So I don&rsquo;t know much about this one, I read that C variadic arguments <code>int printf (const char *format, ... )</code> uses it. Another big advantage of using registers is that all operations in RISC architectures are done within registers so it&rsquo;s an overhead to [store to]/[load from] memory if we can keep data in registers.</li>
<li><strong>Local Variable Space (optional)</strong>: Each local variable used by the function can be stored here.</li>
<li>To know more about these other areas, please refer to: <a href="https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture">64-Bit ELF V2 ABI Specification: Power Architecture</a>.</li>
</ul>
<p><strong>Why are 160 bytes allocated from the stack?</strong>:</p>
<p>32 bytes is the minimum required, then 8 times 8 bytes for the Parameter Save Area (if needed), and 8 times 8 bytes for the Local Variable Space (if needed); 32 + (8 * 8) + (8 * 8) = 160 (it&rsquo;s also doubleword aligned). This is certainly not optimized but attends my requirement to have some generic for testing purposes.</p>
<h3 id=parameters>Parameters<a hidden class=anchor aria-hidden=true href=#parameters>#</a></h3>
<p>As I wrote above, parameters are passed in registers, PowerPC64 ABI assigns 8 registers for it from <strong>R3</strong> to <strong>R13</strong>. Vector and floating point data are passed in their own registers but this project don&rsquo;t cover them.</p>
<h3 id=return-values>Return Values<a hidden class=anchor aria-hidden=true href=#return-values>#</a></h3>
<p>As per the ABI</p>
<blockquote>
<p>Functions that return values of the following types shall place the result in register r3 as signed or unsigned integers, as appropriate, and sign extended or zero extended to 64 bits where necessary:</p>
<ul>
<li>char</li>
<li>enum</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>pointer to any type</li>
<li>_Bool</li>
</ul>
</blockquote>
<h3 id=answer-to-part-i2017functions-in-assembly-question>Answer to <a href=/2017/functions-in-assembly>Part I</a> question<a hidden class=anchor aria-hidden=true href=#answer-to-part-i2017functions-in-assembly-question>#</a></h3>
<p>The code <code>int i = my_function(5); // i == 5</code> should makes sense now: <code>main()</code> puts 5 in <strong>R3</strong> register as argument to <code>my_function()</code>, which is the <strong>same register used to return value</strong>. Thus, after <code>my_function()</code> returns, <code>main()</code> reads the return value from <strong>R3</strong> which is, in this case, still <strong>5</strong>.</p>
<h3 id=the-code>The Code<a hidden class=anchor aria-hidden=true href=#the-code>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>    .align <span style=color:#2aa198>2</span>
    .type <span style=color:#cb4b16>my_function</span>,@function<span style=color:#586e75>;
</span><span style=color:#586e75></span>    <span style=color:#cb4b16>.globl</span> <span style=color:#cb4b16>my_function</span><span style=color:#586e75>;
</span><span style=color:#586e75></span>    <span style=color:#cb4b16>my_function</span>:
        <span style=color:#268bd2>addis</span> <span style=color:#2aa198>2</span>, <span style=color:#2aa198>12</span>, <span style=color:#cb4b16>.TOC.-my_function@ha</span><span style=color:#586e75>;
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>addi</span> <span style=color:#2aa198>2</span>, <span style=color:#2aa198>2</span>, <span style=color:#cb4b16>.TOC.-my_function@l</span><span style=color:#586e75>;
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>.localentry</span> <span style=color:#cb4b16>my_function</span>, <span style=color:#cb4b16>.-my_function</span>
        <span style=color:#268bd2>mflr</span> <span style=color:#2aa198>0</span>
        <span style=color:#268bd2>std</span> <span style=color:#2aa198>0</span>, <span style=color:#2aa198>16</span>(<span style=color:#2aa198>1</span>)
        <span style=color:#268bd2>stdu</span> <span style=color:#2aa198>1</span>, -<span style=color:#2aa198>160</span>(<span style=color:#2aa198>1</span>)
    
        <span style=color:#268bd2>add</span> <span style=color:#2aa198>3</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>
    
        <span style=color:#268bd2>addi</span> <span style=color:#2aa198>1</span>, <span style=color:#2aa198>1</span>, <span style=color:#2aa198>160</span>
        <span style=color:#268bd2>ld</span> <span style=color:#2aa198>0</span>, <span style=color:#2aa198>16</span>(<span style=color:#2aa198>1</span>)
        <span style=color:#268bd2>mtlr</span> <span style=color:#2aa198>0</span>
        <span style=color:#268bd2>blr</span></code></pre></div>
<p>All instructions here exists to build the call stack, except <code>add 3, 3, 4</code>. The code before the computation code is named <strong>prologue</strong>. In this case, it initializes the TOC pointer in register <strong>R2</strong> for the following reason:</p>
<blockquote>
<p>All functions have a global entry point (GEP) available to any caller and pointing to the beginning of the prologue. Some functions may have a secondary entry point to optimize the cost of TOC pointer management. In particular, functions within a common module sharing the same TOC base value in r2 may be entered using a secondary entry point (the local entry point or LEP) that may bypass the code that loads a suitable TOC pointer value into the r2 register. When a dynamic or global linker transfers control from a function to another function in the same module, it may choose (but is not required) to use the local entry point when the r2 register is known to hold a valid TOC base value.</p>
</blockquote>
<p>Basically, the prologue handles the TOC pointer, saves the Link Register and &ldquo;allocates&rdquo; 160 bytes by setting the stack pointer. After the computation code, we have the <strong>epilogue</strong> which restores the prologue before returning. In this case, we reset the stack pointer 160 bytes, load the LR address to <strong>R0</strong> and put that value back into the Link Register and return.</p>
<p>To know more about PowerPC instruction set, checkout <a href="https://openpowerfoundation.org/?resource_lib=power-isa-version-3-0">IBM Power ISA™ Version 3.0B</a>.</p>
<h3 id=the-end>The End<a hidden class=anchor aria-hidden=true href=#the-end>#</a></h3>
<p>Just to make things easier we can create a macro to add both prologue/epilogue for us:</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console>    $ cat util.h
</code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>    <span style=color:#586e75>#ifndef _UTIL_H
</span><span style=color:#586e75></span>    <span style=color:#586e75>#define _UTIL_H
</span><span style=color:#586e75></span>    
    <span style=color:#586e75>#define FUNCTION(name)              \
</span><span style=color:#586e75></span>        .align <span style=color:#2aa198>2</span><span style=color:#586e75>;                       \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>.type</span> <span style=color:#cb4b16>name</span>, @function<span style=color:#586e75>;          \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>.globl</span> <span style=color:#cb4b16>name</span><span style=color:#586e75>;                    \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>name</span>:                           \
            <span style=color:#268bd2>addis</span> <span style=color:#2aa198>2</span>, <span style=color:#2aa198>12</span>, <span style=color:#cb4b16>.TOC.-name@ha</span><span style=color:#586e75>; \
</span><span style=color:#586e75></span>            <span style=color:#cb4b16>addi</span> <span style=color:#2aa198>2</span>, <span style=color:#2aa198>2</span>, <span style=color:#cb4b16>.TOC.-name@l</span><span style=color:#586e75>;    \
</span><span style=color:#586e75></span>            <span style=color:#cb4b16>.localentry</span> <span style=color:#cb4b16>name</span>,.-<span style=color:#cb4b16>name</span><span style=color:#586e75>;    \
</span><span style=color:#586e75></span>            <span style=color:#cb4b16>mflr</span> <span style=color:#2aa198>0</span><span style=color:#586e75>;                     \
</span><span style=color:#586e75></span>            <span style=color:#cb4b16>std</span> <span style=color:#2aa198>0</span>, <span style=color:#2aa198>16</span>(<span style=color:#2aa198>1</span>)<span style=color:#586e75>;               \
</span><span style=color:#586e75></span>            <span style=color:#cb4b16>stdu</span> <span style=color:#2aa198>1</span>, -<span style=color:#2aa198>160</span>(<span style=color:#2aa198>1</span>)<span style=color:#586e75>;
</span><span style=color:#586e75></span>    
    <span style=color:#586e75>#define ENDFUNCTION                 \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>addi</span> <span style=color:#2aa198>1</span>, <span style=color:#2aa198>1</span>, <span style=color:#2aa198>160</span><span style=color:#586e75>;                 \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>ld</span> <span style=color:#2aa198>0</span>, <span style=color:#2aa198>16</span>(<span style=color:#2aa198>1</span>)<span style=color:#586e75>;                    \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>mtlr</span> <span style=color:#2aa198>0</span><span style=color:#586e75>;                         \
</span><span style=color:#586e75></span>        <span style=color:#cb4b16>blr</span><span style=color:#586e75>;
</span><span style=color:#586e75></span>    
    #<span style=color:#cb4b16>endif</span></code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console>    $ cat function.S
</code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>    <span style=color:#586e75>#include &#34;util.h&#34;
</span><span style=color:#586e75></span>    .align <span style=color:#2aa198>2</span>
    .printf_fmt:
        .string <span style=color:#2aa198>&#34;\t=&gt; %d\n&#34;</span>
    
    <span style=color:#268bd2>FUNCTION</span>(<span style=color:#cb4b16>print_sum</span>)
        <span style=color:#268bd2>add</span> <span style=color:#2aa198>4</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>3</span>
        <span style=color:#268bd2>addis</span> <span style=color:#2aa198>3</span>, <span style=color:#2aa198>2</span>, <span style=color:#cb4b16>.printf_fmt@toc@ha</span>
        <span style=color:#268bd2>addi</span> <span style=color:#2aa198>3</span>, <span style=color:#2aa198>3</span>, <span style=color:#cb4b16>.printf_fmt@toc@l</span>
        <span style=color:#268bd2>bl</span> <span style=color:#cb4b16>printf</span>
        <span style=color:#268bd2>nop</span>
    <span style=color:#268bd2>ENDFUNCTION</span></code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console>    $ cat function.c
</code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>    <span style=color:#719e07>extern</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>print_sum</span>(<span style=color:#dc322f>int</span> a, <span style=color:#dc322f>int</span> b);
    
    <span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
    {
        print_sum(<span style=color:#2aa198>10</span>, <span style=color:#2aa198>8</span>);
        printf(<span style=color:#2aa198>&#34;Works! ;-)</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
    }</code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console>    $ gcc function.S function.c -o function
    $ ./function
            =&gt; 18
    Works! ;-)
</code></pre></div>
<h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3>
<ul>
<li><a href="https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture">PowerPC 64-bit ELF V2 ABI</a></li>
<li><a href="https://openpowerfoundation.org/?resource_lib=power-isa-version-3-0">IBM Power ISA™ Version 3.0B</a></li>
<li><a href=https://en.wikipedia.org/wiki/Application_binary_interface>Application binary interface</a></li>
<li><a href=https://en.wikipedia.org/wiki/Call_stack>Call Stack</a></li>
<li><a href=https://www.ibm.com/developerworks/library/l-ppc/>PowerPC Assembly</a></li>
<li><a href=https://www.ibm.com/developerworks/linux/library/l-powasm4/index.html>Function calls and the PowerPC 64-bit ABI</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://jrziviani.github.io/tags/c/>C</a></li>
<li><a href=https://jrziviani.github.io/tags/assembly/>assembly</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://jrziviani.github.io/posts/elegant-visitors/>
<span class=title>« Prev Page</span>
<br>
<span>Elegant Visitors</span>
</a>
<a class=next href=https://jrziviani.github.io/posts/my-first-fpga-board/>
<span class=title>Next Page »</span>
<br>
<span>FPGA Cyclone IV - Altera</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://jrziviani.github.io>ziviani.net</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>